-- vim: ft=lua
-- Inspired by whynothugo's lsp config
{{ $servers := 0 }}
-- Define enabled servers
local servers = {
{{ if lookPath "rust-analyzer" -}}
rust_analyzer = {},
{{- $servers = add1 $servers -}}
{{- end }}
{{ if lookPath "gopls" -}}
gopls = {
  settings = {
    gopls = {
      staticcheck = true,
    },
  },
},
{{- $servers = add1 $servers -}}
{{- end }}
{{ if lookPath "clangd" -}}
clangd = {},
{{ else if lookPath "ccls" -}}
ccls = {},
{{- $servers = add1 $servers -}}
{{- end }}
}

{{ if gt $servers 0 -}}
local lspconfig = require("lspconfig")

-- TODO: use lsp_status for capabilites
local on_attach = function(client, bufnr)
  -- Set autocommands conditional on server_capabilities
  -- TODO: add implementation, declaration and signature help
  if client.resolved_capabilities.goto_definition then
    vim.keymap.nnoremap({
      "<Leader>ld",
      vim.lsp.buf.definition,
      buffer = true,
    })
  end
  if client.resolved_capabilities.declaration then
    vim.keymap.nnoremap({
      "<Leader>lD",
      vim.lsp.buf.declaration,
      buffer = true,
    })
  end
  if client.resolved_capabilities.hover then
    vim.fn.sign_define('LightBulbSign', { text = "", texthl = "String", linehl="", numhl="" })
    vim.cmd([[autocmd CursorHold,CursorHoldI,InsertLeave <buffer> lua require"nvim-lightbulb".update_lightbulb()]])
    vim.keymap.nnoremap({
      "<CR>",
      vim.lsp.buf.hover,
      buffer = true,
    })
  end
  if client.resolved_capabilities.code_action then
    vim.keymap.nnoremap({
      "<Leader>la",
      [[<cmd>Telescope lsp_code_actions theme=get_cursor<CR>]],
      buffer = true,
    })
    vim.keymap.vnoremap({
      "<Leader>la",
      [[<cmd>Telescope lsp_range_code_actions theme=get_cursor<CR><Esc>]],
      buffer = true,
    })
  end
  if client.resolved_capabilities.signature_help then
    vim.keymap.nnoremap({
      "<Leader><CR>",
      vim.lsp.buf.signature_help,
      buffer = true,
    })
  end
  if client.resolved_capabilities.rename then
    vim.keymap.nnoremap({
      "<Leader>lr",
      vim.lsp.buf.rename,
      buffer = true,
    })
  end
  if client.resolved_capabilities.find_references then
    vim.keymap.nnoremap({
      "<Leader>*",
      vim.lsp.buf.references,
      buffer = true,
    })
  end
  -- if client.resolved_capabilities.code_lens then
  --   vim.api.nvim_command [[autocmd CursorHold,CursorHoldI,InsertLeave <buffer> lua vim.lsp.codelens.refresh()]]
  --   vim.keymap.nmap({
  --     "<Leader>lc",
  --     vim.lsp.codelens.run,
  --     silent = true,
  --     buffer = true,
  --   })
  -- end
  vim.keymap.nnoremap({
    "]d",
    function()
      vim.lsp.diagnostic.goto_next({enable_popup=false})
    end,
    buffer = true,
  })
  vim.keymap.nnoremap({
    "[d",
    function()
      vim.lsp.diagnostic.goto_next({enable_popup=false})
    end,
    buffer = true,
  })
  vim.keymap.nnoremap({
    "<Leader>ll",
    vim.lsp.diagnostic.set_loclist,
    buffer = true,
  })
  vim.keymap.nnoremap({
    "<Leader>lt",
    require("modules.lsp.utils").toggle_hover_diagnostics,
    buffer = true,
  })
  vim.cmd([[autocmd CursorHold,InsertEnter,InsertLeave <buffer> lua require"modules.lsp.utils".update_hover_diagnostics()]])

  require("utils.keychord").cancel("<Leader>l", true)

  -- Additional plugins
  require("cmp_nvim_lsp").setup()
end

-- config that activates keymaps and enables snippet support
local make_config = function()
  local capabilities = vim.lsp.protocol.make_client_capabilities()
  capabilities.textDocument.completion.completionItem.snippetSupport = true
  capabilities.textDocument.completion.completionItem.preselectSupport = true
  capabilities.textDocument.completion.completionItem.insertReplaceSupport = true
  capabilities.textDocument.completion.completionItem.labelDetailsSupport = true
  capabilities.textDocument.completion.completionItem.deprecatedSupport = true
  capabilities.textDocument.completion.completionItem.commitCharactersSupport = true
  capabilities.textDocument.completion.completionItem.tagSupport = { valueSet = { 1 } }
  capabilities.textDocument.completion.completionItem.resolveSupport = {
    properties = {
      "documentation",
      "detail",
      "additionalTextEdits",
    },
  }
  return {
    -- enable snippet support
    capabilities = capabilities,
    -- map buffer local keybindings when the language server attaches
    on_attach = on_attach,
    autostart = true,
    flags = {
      debounce_text_changes = 250,
    },
    handlers = {
      ['textDocument/publishDiagnostics'] = vim.lsp.with(
      vim.lsp.diagnostic.on_publish_diagnostics, {
        virtual_text = false,
        underline = true,
        signs = true,
        update_in_insert = false,
      }),
    },
  }
end

-- Requires codicon font
-- vim.lsp.protocol.CompletionItemKind = {
--   "  Text", -- = 1
--   "  Function", -- = 2;
--   "  Method", -- = 3;
--   "  Constructor", -- = 4;
--   "  Field", -- = 5;
--   "  Variable", -- = 6;
--   "  Class", -- = 7;
--   "  Interface", -- = 8;
--   "  Module", -- = 9;
--   "  Property", -- = 10;
--   "  Unit", -- = 11;
--   "  Value", -- = 12;
--   "  Enum", -- = 13;
--   "  Keyword", -- = 14;
--   "  Snippet", -- = 15;
--   "  Color", -- = 16;
--   "  File", -- = 17;
--   "  Reference", -- = 18;
--   "  Folder", -- = 19;
--   "  EnumMember", -- = 20;
--   "  Constant", -- = 21;
--   "  Struct", -- = 22;
--   "  Event", -- = 23;
--   "  Operator", -- = 24;
--   "  TypeParameter", -- = 25;
-- }

-- Change diagnostic symbols in the sign column
local signs = { Error = " ", Warning = " ", Hint = " ", Information = " " }

for type, icon in pairs(signs) do
  local hl = "LspDiagnosticsSign" .. type
  vim.fn.sign_define(hl, { text = icon, texthl = hl, numhl = "" })
end

-- Register all the LSP servers.
local common_config = make_config()
for server, config in pairs(servers) do
  -- Merge per-LSP configs with the common settings, and use that:
  lspconfig[server].setup(vim.tbl_extend("keep", config, common_config))
end
{{- end }}
